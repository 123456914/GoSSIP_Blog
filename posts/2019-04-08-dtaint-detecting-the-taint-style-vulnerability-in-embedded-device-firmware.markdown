---
layout: post
title: "DTaint: Detecting the Taint-Style Vulnerability in Embedded Device Firmware"
date: 2019-04-08 12:13:28 +0800
comments: true
categories: 
---
作者：Kai Cheng, Qiang Li, Lei Wang, Qian Chen, Yaowen Zheng, Limin Sun, Zhenkai Liang 

单位： Beijing Jiaotong University, University of Chinese Academy of Sciences, National University of Singapore

会议：DSN'18

原文：https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8416504

<hr/>

### 1 INTRODUCTION

作者提出了一种静态二进制分析方法DTaint，用于检测firmware中的污点漏洞。

由于很多厂商（90%）没有提供firmware的公开源码，并且制造商通常使用专有硬件组件定制固件，很难进行动态分析。

- 动态分析

  作者使用FIRMADYNE——自动化固件动态分析系统，来分析2009-2016收集的firmware镜像，发现只有一小部分（少于670）firmware可以被模拟用于发现漏洞。

  ![](/images/2019-04-08/fig1.PNG)

- 污点式漏洞

  指的是由于对用户输入没有进行有效过滤，导致攻击者提供输入到达一个不安全的敏感位置，产生系统安全漏洞。例如，缓冲区溢出和命令行注入。发现该漏洞分为三个阶段：

  - 识别attacker-controlled sources。标记数据输入为tainted point，表示输入来源。
  - 识别security-sensitive sinks。标记不安全的库函数或代码作为sink，表示在这些位置数据可能会成为一个漏洞。
  - 找到漏洞作为不安全数据路径。获得输入和sink之间的数据传播过程，如果路径缺乏安全过滤，可以将其标记为不安全路径。

- 特点：

  - 首次在设备固件的二进制代码中检查污点式漏洞
  - 与传统工具相比，DTaint可以检测更多的漏洞，使用更短的时间

<!--more-->
### 2 IMPLEMENTATION

![](/images/2019-04-08/fig4.PNG)

DTaint工具一共分为三个模块：

- 静态符号分析（900行python代码）
- 数据流生成模块（2200行python代码）
- 漏洞检测模块（650行python代码）

首先，使用Binwalk API从firmware中提取出文件系统；然后选择感兴趣的二进制文件放入到静态符号分析的模块中，生成IR；在IR中，DTaint生成数据流，选择sink和source来构造三元组 (source, path, sink) ，最后继续进行检查三元组是否缺乏有效的过滤，发现漏洞。

#### 静态符号分析

DTaint将二进制转化为中间语言VEX，对每个函数执行静态符号分析，来生成符号变量、约束表达式和每个变量的数据类型。这里使用Angr中的符号执行引擎模块SimuVEX。

#### 数据流生成

firmware数据流的生成有三个挑战：

- 当指针别名（pointer aliases）存在时，很难通过内存生成数据流。
- 存在很多间接调用，导致数据传播的丢失。
- 自上而下遍历函数调用图会造成大量重复分析。

DTaint数据流生成部分分为四个组件：

- 函数分析
- 指针别名
- 数据结构
- 过程间数据流

##### 函数分析

该组件包括三种技术：

- 内存变量描述Variable Description
- 数据类型推断Data Type
- 每个函数的定义对Definition Pairs

这一部分分析基于VEX IR。DTaint首先为固件每个函数单独的创建CFG。CFG中每个基本块在当前路径生成一个符号状态，DTaint探索每个条件分支的所有方向。当存在循环时，DTaint对于同一循环的基本块只分析一次。因此，一个基本块可能在不同路径中有不同的符号状态。

- 变量描述Variable Description

  当存储或加载内存时，变量由内存或寄存器分配。在绝对地址中，DTaint直接使用内存地址来呈现变量，例如0×670B0。在间接地址中，DTaint使用“base + offset”形式表示变量，其中base是寄存器，offset是寄存器或整数常量。

  DTaint使用*deref*作为内存访问的引用。

  ![](/images/2019-04-08/fig567.PNG)

  R1 = deref(R5 + 0X4C) 《======》 LDR R1, [R5, 0X4C]

- 数据类型Data Type

- 定义对Definition Pairs

  在每个函数中，DTaint都会生成定义对(d, u) ，定义对中的变量是内存和寄存器中的具体值或符号表达式。DTaint使用这些定义函数对来查找指针别名，并生成过程内和过程间数据流。

##### 指针别名Pointer Aliasing

指针别名是指由不同名称 “pointed to” 相同的内存位置的情况。当存在指针别名时，固件中许多数据流可能会找不到。

在二进制代码中，主要考虑两种指针别名：

- “move”指令的指针赋值语句
- “store”指令写入内存的指针

在“store”指针别名中，指针被保存到内存中。例如，int *p = x ; *(q+ 4) = p ， \*(\*(q+ 4 )) 和 *p是别名。如果q 是一个符号值，一般的符号分析无法直接识别 *p 和 \*(\*(q+ 4 ))作为别名。这种情况可以被描述为：

`deref(base1 + offset1) = base2 + offset2`

Algorithm 1显示了DTaint如何识别上述公式的指针别名。

DP —— 每个函数的定义对

ALIAS —— 存放指针别名

DOP —— 存放变量指向的定义

![](/images/2019-04-08/algorithm1.PNG)

##### 数据结构的相似性

这一部分解决间接调用数据流丢失的问题。

DTaint通过计算数据结构的相似性来识别那些间接调用关系。主要原理是指向这个数据结构的对象可以用在多个函数中，它们可以共享相同的数据结构。

- Data Structure Layout

  在二进制，一些指令显示指定数据结构字段的实际偏移量。这些指令可以描述为“ base + offset ” 形式。

  污点式漏洞的特征决定了数据结构通常包含指针。如果将堆栈指针作为参数传递给被调用者，则将使用它作为基指针，并在堆栈上构造Data Structure Layout。

  DTaint通过3元组(b, o, t)表示数据结构，b 是基地址， o 是偏移，t 是类型。多层结构可以描述为S = (S1, S2, ... , Sn），其中S表示具有相同根指针root pointer的字段集合，Si 表示具有相同基址base address的一组字段， n是S中不同基址的数量。

  对于不同的调用图，DTaint通过给定的规则确定它们是否相似，计算他们的相似性。

##### 过程间数据流

传统技术通常生成从顶部到底部遍历函数调用图的数据流，可能会导致重复的分析。

DTaint使用“自下而上”方法遍历调用图以构建过程内和过程间数据流，每个函数仅分析一次。

DTaint使用定义对来构造use-def和def-use链，通过后序遍历调用图来生成数据流。

#### 漏洞检测

DTaint通过生成三元组(source, path, sink)，来识别污点式漏洞。

作者收集了一些常见的库函数，与污点式漏洞相关。

![](/images/2019-04-08/table1.PNG)

对于每一条数据路径，作者实现两种约束表达式来检查污染数据是否从source到sink是否存在安全过滤：

- Buffer overflow vulnerability

  问题是传递给copy操作的长度字段验证不充分。作者为source变量生成了约束表达式，对于每条路径，如果在所有约束表达式中的n上没有约束，路径被标识为漏洞。

- Command injection vulnerability

  由嵌入式Linux系统中的库函数（例如system或popen）引起的。作者将约束表达式用于system函数的第一个参数cmd。对于每个路径，如果在所有约束表达式中的污染变量cmd上没有约束（例如deref（cmd + offset）！=';'），则此路径是漏洞。

### 3 EVALUATION

设备：64bit 4核 Intel CPU 、128GB RAM、Ubuntu 16.04 LTS系统

#### 漏洞检测

作者测试6款firmware images，来自四家不同的设备制造商，包括Hikvision，Uniview，Netgear和D-Link。

![](/images/2019-04-08/table2.PNG)

表3显示了使用DTaint分析六6个固件镜像时，污点式漏洞的主要信息。

![](/images/2019-04-08/table3.PNG)

作者在这些固件镜像中一共找到了21个污点式漏洞。其中由于某些firmware很大，并且十分复杂，Angr工具无法正常分析，作者手工提取出了一些函数进行分析。

表格4显示了之前的已知漏洞，来自CVE database和exploit database。

![](/images/2019-04-08/table4.PNG)

表格5显示了由DTaint检测出之前未知的0-day漏洞。

![](/images/2019-04-08/table5.PNG)



#### 性能

作者使用了四个程序来评估DTaint：OpenSSL，cgibin，setup.cgi和httpd。在同一组程序中使用Angr作为参考。

##### 资源开销

![](/images/2019-04-08/table6.PNG)

静态符号分析模块占用大部分资源，15GB内存和25％CPU使用率。

DTaint开销随着固件系统复杂性的增加而增长。

##### 时间开销

![](/images/2019-04-08/table7.PNG)

在静态符号分析（SSA）中，DTaint比Angr花费的时间更少。在数据依赖图（DDG）生成中，DTaint花费的时间明显减少。

这是由于DTaint专注于污点分析，每个函数将被分析一次。

### 4 CONCLUSION

在没有firmware源代码的情况下，可以使用DTaint工具对二进制文件进行静态分析，检测污点式漏洞。

相比传统工具，DTaint可以花费更少的时间。

但文章中没有提到漏报和误报情况。